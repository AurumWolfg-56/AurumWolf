
import React, { createContext, useContext, useEffect, useState } from 'react';
import { supabase } from '../lib/supabase';
import { useAuth } from './AuthContext';
import { Investment } from '../types';
import { parseSupabaseData } from '../lib/supabaseSafe';
import { InvestmentSchema } from '../lib/validators';

interface InvestmentsContextType {
    investments: Investment[];
    loading: boolean;
    error: string | null;
    addInvestment: (inv: Investment) => Promise<void>;
    updateInvestment: (inv: Investment) => Promise<void>;
    deleteInvestment: (id: string) => Promise<void>;
    refreshInvestments: () => Promise<void>;
    refreshRealTimeQuotes: () => Promise<void>;
}

const InvestmentsContext = createContext<InvestmentsContextType | undefined>(undefined);

export function InvestmentsProvider({ children }: { children: React.ReactNode }) {
    const { user } = useAuth();
    const [investments, setInvestments] = useState<Investment[]>([]);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState<string | null>(null);

    const fetchInvestments = async () => {
        if (!user) {
            setInvestments([]);
            setLoading(false);
            return;
        }

        try {
            setLoading(true);
            const { data, error } = await supabase
                .from('investments')
                .select('*')
                .eq('user_id', user.id);

            if (error) throw error;

            const candidates = (data || []).map(i => ({
                id: i.id,
                name: i.name,
                ticker: i.ticker,
                type: i.type,
                strategy: i.strategy,
                quantity: i.quantity,
                costBasis: i.cost_basis,
                currentPrice: i.current_price,
                currency: i.currency,
                lastUpdated: i.last_updated,
                notes: i.notes || '',
                // Calculated fields (runtime only)
                currentValue: i.quantity * i.current_price,
                unrealizedPnL: (i.quantity * i.current_price) - (i.quantity * i.cost_basis),
                roiPercent: i.cost_basis > 0 ? (((i.quantity * i.current_price) - (i.quantity * i.cost_basis)) / (i.quantity * i.cost_basis)) * 100 : 0
            }));

            const validInvestments = parseSupabaseData(InvestmentSchema, candidates, []) as Investment[];
            setInvestments(validInvestments);
        } catch (err: any) {
            console.error('Error fetching investments:', err);
            setError(err.message);
        } finally {
            setLoading(false);
        }
    };

    useEffect(() => {
        fetchInvestments();
    }, [user]);

    const addInvestment = async (inv: Investment) => {
        // Optimistic
        const prevInvestments = [...investments];
        // We need a temporary ID for the optimistic state if not provided
        // But inv usually comes with an ID generated by crypto.randomUUID() from the UI form
        setInvestments(prev => [...prev, inv]);

        if (!user) return;
        try {
            const { data, error } = await supabase
                .from('investments')
                .insert([{
                    id: inv.id,
                    user_id: user.id,
                    name: inv.name,
                    ticker: inv.ticker,
                    type: inv.type,
                    strategy: inv.strategy,
                    quantity: inv.quantity,
                    cost_basis: inv.costBasis,
                    current_price: inv.currentPrice,
                    currency: inv.currency,
                    notes: inv.notes
                }])
                .select()
                .single();

            if (error) throw error;
        } catch (err: any) {
            console.error('Error adding investment:', err);
            setError(err.message);
            setInvestments(prevInvestments); // Rollback
        }
    };

    const updateInvestment = async (inv: Investment) => {
        const prevInvestments = [...investments];
        // Recalculate derived fields for optimistic update
        const updatedInv: Investment = {
            ...inv,
            currentValue: inv.quantity * inv.currentPrice,
            unrealizedPnL: (inv.quantity * inv.currentPrice) - (inv.quantity * inv.costBasis),
            roiPercent: inv.costBasis > 0 ? (((inv.quantity * inv.currentPrice) - (inv.quantity * inv.costBasis)) / (inv.quantity * inv.costBasis)) * 100 : 0
        };
        setInvestments(prev => prev.map(i => i.id === inv.id ? updatedInv : i));

        if (!user) return;
        try {
            const { error } = await supabase
                .from('investments')
                .update({
                    name: inv.name,
                    ticker: inv.ticker,
                    type: inv.type,
                    strategy: inv.strategy,
                    quantity: inv.quantity,
                    cost_basis: inv.costBasis,
                    current_price: inv.currentPrice,
                    currency: inv.currency,
                    notes: inv.notes,
                    last_updated: new Date().toISOString()
                })
                .eq('id', inv.id);

            if (error) throw error;
        } catch (err: any) {
            console.error('Error updating investment:', err);
            setError(err.message);
            setInvestments(prevInvestments); // Rollback
        }
    };

    const deleteInvestment = async (id: string) => {
        const prevInvestments = [...investments];
        setInvestments(prev => prev.filter(i => i.id !== id));

        if (!user) return;
        try {
            const { error } = await supabase
                .from('investments')
                .delete()
                .eq('id', id);

            if (error) throw error;
        } catch (err: any) {
            console.error('Error deleting investment:', err);
            setError(err.message);
            setInvestments(prevInvestments); // Rollback
        }
    };

    // --- MARKET SIMULATION ---
    const refreshRealTimeQuotes = async () => {
        if (!user || investments.length === 0) return;
        setLoading(true); // Short loading state for effect

        const prevInvestments = [...investments];
        const updatedInvestments = investments.map(inv => {
            // Simulate -2% to +2% fluctuation
            const volatility = 0.02;
            const change = 1 + (Math.random() * (volatility * 2) - volatility);
            const newPrice = inv.currentPrice * change;

            return {
                ...inv,
                currentPrice: newPrice,
                currentValue: inv.quantity * newPrice,
                unrealizedPnL: (inv.quantity * newPrice) - (inv.quantity * inv.costBasis),
                roiPercent: inv.costBasis > 0 ? (((inv.quantity * newPrice) - (inv.quantity * inv.costBasis)) / (inv.quantity * inv.costBasis)) * 100 : 0,
                lastUpdated: new Date().toISOString()
            };
        });

        setInvestments(updatedInvestments);

        // Ideally we batch update Suapbase, but loop is fine for < 20 items
        try {
            const updates = updatedInvestments.map(inv =>
                supabase.from('investments')
                    .update({
                        current_price: inv.currentPrice,
                        last_updated: inv.lastUpdated
                    })
                    .eq('id', inv.id)
            );
            await Promise.all(updates);
        } catch (err) {
            console.error("Market data sync failed", err);
            // Non-critical, no rollback needed for simulation
        } finally {
            setLoading(false);
        }
    };

    const value = {
        investments,
        loading,
        error,
        addInvestment,
        updateInvestment,
        deleteInvestment,
        refreshInvestments: fetchInvestments,
        refreshRealTimeQuotes
    };

    return <InvestmentsContext.Provider value={value}>{children}</InvestmentsContext.Provider>;
}

export const useInvestments = () => {
    const context = useContext(InvestmentsContext);
    if (context === undefined) {
        throw new Error('useInvestments must be used within an InvestmentsProvider');
    }
    return context;
};
